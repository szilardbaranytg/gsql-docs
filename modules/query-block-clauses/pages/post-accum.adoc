= POST-ACCUM

The optional `POST-ACCUM` clause enables aggregation and other computations across the set of vertices projected from the `FROM-WHERE` binding table. `POST-ACCUM` can be used without `ACCUM`. If it is preceded by an `ACCUM` clause, then its statement can access the new snapshot value of accumulators computed by the `ACCUM` clause.


== Syntax

[source,gsql]
----
postAccumClause := POST-ACCUM ["(" vertexAlias ")"] dmlSubStmtList
dmlSubStmtList := dmlSubStmt ["," dmlSubStmt]*
dmlSubStmt := assignStmt           // Assignment
            | funcCallStmt         // Function Call
            | gAccumAccumStmt      // Assignment
            | lAccumAccumStmt      // Assignment
            | attrAccumStmt        // Assignment
            | vAccumFuncCall       // Function Call
            | localVarDeclStmt     // Declaration
            | dmlSubCaseStmt       // Control Flow
            | dmlSubIfStmt         // Control Flow
            | dmlSubWhileStmt      // Control Flow
            | dmlSubForEachStmt    // Control Flow
            | BREAK                // Control Flow
            | CONTINUE             // Control Flow
            | insertStmt           // Data Modification
            | dmlSubDeleteStmt     // Data Modification
            | printlnStmt          // Output
            | logStmt              // Output
----

== Semantics

*Example 1:
[source,gsql]
----
USE GRAPH financialGraph

CREATE OR REPLACE DISTRIBUTED QUERY q1 (/* parameters */) FOR GRAPH financialGraph SYNTAX V2 {

    SumAccum<INT> @cnt = 0; //local accumulator
    SumAccum<INT>  @@testCnt1 = 0; //global accumulator
    SumAccum<INT>  @@testCnt2 = 0; //global accumulator

   S = SELECT a
       FROM Account:a - (hasPhone:e) - Phone:p
       WHERE a.isBlocked == "yes"
       //a.@cnt snapshot value is 0
       ACCUM  a.@cnt +=1, //add 1 to a.@cnt
              @@testCnt1+= a.@cnt //access a.@cnt snapshot value 0
       POST-ACCUM (a) //loop vertex “a” set.
          @@testCnt2 += a.@cnt; //access a.@cnt new snapshot value 1


   PRINT @@testCnt1;
   PRINT @@testCnt2;
   PRINT S;

}

INSTALL QUERY q1


RUN QUERY q1()
----

*Result:*
[source,json]
----
{
  "version": {
    "edition": "enterprise",
    "api": "v2",
    "schema": 1
  },
  "error": false,
  "message": "",
  "results": [
    {
      "@@testCnt1": 0
    },
    {
      "@@testCnt2": 1
    },
    {
      "S": [
        {
          "v_id": "Jay",
          "v_type": "Account",
          "attributes": {
            "name": "Jay",
            "isBlocked": "yes",
            "@cnt": 1
          }
        }
      ]
    }
  ]
}
----

=== FROM-WHERE Produces A Binding Table

We can think of the `FROM` and `WHERE` clauses specifying a binding table, where the `FROM` clause specifies the pattern, and the `WHERE` clause does a post-filter of the matched pattern instances-- the result is a table, each row in the table is a pattern instance with the binding variables specified in the FROM clause as columns. Example 1 FROM clause produces a result table (a, e, p) where “a” is the Account variable, “e” is the “hasPhone” variable, and “p” is the Phone variable.

=== ACCUM Loops Each Row in the Binding Table

The `ACCUM` clause executes its statement(s) once for each row in the result table. The execution is done in a map-reduce fashion.

Map-Reduce Interpretation: The ACCUM clause uses snapshot semantics, executing in two phases:


1. *Map Phase*: Each row in the binding table is processed in parallel, starting with the same accumulator snapshot to compute inputs. The snapshot of accumulator values is taken before the start of the ACCUM clause.
2. *Reduce Phase*: These inputs are aggregated into their respective accumulators, creating a new snapshot of accumulator values.

The new snapshot is available for access after the `ACCUM` clause finishes.


=== POST-ACCUM Loops A Vertex Set Selected From the Binding Table

The `POST-ACCUM` clause is designed to do some computation based on a selected vertex set from the binding table. It
executes its statements(s) once for each distinct value of a referenced vertex column from the binding table. You can
have multiple `POST-ACCUM` clauses. But each POST-ACCUM clause can only refer to one vertex variable defined in the FROM clause.
In Example 1, POST-ACCUM (a) means we project the vertex “a” column from the binding table,  remove the duplicates, and
loop through the resulting vertex set.


Another characteristic of the `POST-ACCUM` clause is that its statement(s) can access the aggregated accumulator value computed in the `ACCUM` clause.

In Example 1,  the `POST-ACCUM` statement will loop over the vertex set “a”, and its statement  `@@testCnt2+=a.@cnt` will read the updated snapshot value of `@a.cnt`, which is 1.

*Example 2:*
[source,gsql]
----
USE GRAPH financialGraph

CREATE OR REPLACE DISTRIBUTED QUERY q1 (/* parameters */) FOR GRAPH financialGraph SYNTAX V2 {

     SumAccum<int> @@edgeCnt = 0;
     MaxAccum<int> @maxAmount = 0;
     MinAccum<int> @minAmount = 100000;

     MaxAccum<int> @@maxSenderAmount = 0;
     MinAccum<int> @@minReceiverAmount = 100000;
     SumAccum<int> @@bCnt = 0;
     SumAccum<int> @@aCnt = 0;

    S = SELECT b
        FROM Account:a - (Transfer>:e) - Account:b
        WHERE a.isBlocked == "no"
        ACCUM  a.@maxAmount += e.amount, //sender max amount
               b.@minAmount += e.amount, //receiver min amount
                @@edgeCnt +=1
        POST-ACCUM (a) @@maxSenderAmount += a.@maxAmount
        POST-ACCUM (b) @@minReceiverAmount += b.@minAmount
        POST-ACCUM (a) @@aCnt +=1
        POST-ACCUM (b) @@bCnt +=1 ;

  PRINT @@maxSenderAmount,  @@minReceiverAmount;
  PRINT @@edgeCnt, @@aCnt, @@bCnt;

}

INSTALL QUERY q1


RUN QUERY q1()
----

*Result:*
[source,gsql]
----
{
  "version": {
    "edition": "enterprise",
    "api": "v2",
    "schema": 1
  },
  "error": false,
  "message": "",
  "results": [
    {
      "@@maxSenderAmount": 10,
      "@@minReceiverAmount": 4
    },
    {
      "@@edgeCnt": 9,
      "@@aCnt": 6,
      "@@bCnt": 6
    }
  ]
}
----

When you reference a vertex alias in a `POST-ACCUM` statement, you bind that vertex alias to the `POST-ACCUM` clause implicitly.
You can also explicitly bind a vertex alias with a `POST-ACCUM` clause by putting the vertex alias in parentheses immediately
after the keyword `POST-ACCUM`. Each `POST-ACCUM` clause must be bound with one and only one vertex alias.


In Example 2, we have multiple `POST-ACCUM` clauses, each will be looping one selected vertex set.

1. `POST-ACCUM (a) @@maxSenderAmount += a.@maxAmount`: In this statement, we loop through the vertex set "a", accessing the aggregate result value `a.@maxAmount` from the `ACCUM` clause. We can write the same statement by removing “(a)”: `POST-ACCUM @@maxSenderAmount += a.@maxAmount`. The compiler will infer the POST-ACCUM is looping “a”.
2. `POST-ACCUM (b) @@minReceiverAmount += b.@minAmount`: in this statement, we loop through the vertex set “b”, accessing the aggregate result value b.@minAmount
3. `POST-ACCUM (a) @@aCnt +=1`:  in this statement, we loop through the vertex set “a”, for each distinct “a”, we increment `@@aCnt`.
4. `POST-ACCUM (b) @@bCnt +=1`: in this statement, we loop through the vertex set “b”, for each distinct “b”, we increment `@@bCnt`.


Note that you can only access one vertex alias in a `POST-ACCUM`. Below example is not allowed, as it has two vertex alias (a, b) in  `a.@maxAmount` and `b.@maxAmount` respectively.
`POST-ACCUM @@maxSenderAmount += a.@maxAmount + b.@maxAmount;`