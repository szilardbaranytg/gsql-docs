= Change a Graph Schema
:source-highlighter: rouge
:rouge-style: monokai


After a graph schema has been created, it can be modified.
This article explains how to change a graph schema by creating and running a schema change job.

Before we proceed, it is important to understand the concepts of global scope and graph scope.

== Global Scope vs. Graph Scope
A database uses Data Definition Language (DDL) to create and modify schema objects. Schema objects include vertex types, edge types, graph types, etc. These schema objects reside in the metadata store, known as the Catalog.

Each schema object is visible within a scope. In a graph database, there are two scopes:

* *Global Scope*: This is the default scope for schema objects. By default, all objects created using the "CREATE" DDL statement belong to the global scope.
* *Graph Scope*: Each graph has its own graph scope. A schema change job can be used to add schema objects (vertex or edge types) to a specific graph's scope.


.Global scope schema objects
image::Global_Local.png[]

As illustrated in Figure 1, we can use CREATE statements to create the
`Account`, `City`, and `Phone` vertex schema object, and the `isLocatedIn`, `hasPhone`, `Transfer`, and `Transfer_Reverse` edge schema
object, and the `financialGraph` graph schema object. They are all visible in the Global scope.

To enter the global scope, type the `use global` command in the GSQL shell. Next, use the `ls` command to list all the
schema objects under this scope.

[source,gsql]
----
> USE GLOBAL
> ls
----

.Global scope schema objects and graph scope objects
image::Global_Local_With_Arrows.png[]



The figure above shows that the `financialGraph` is composed of global scope schema objects such as `Account`, `City`, `Phone`, `isLocatedIn`,
and `hasPhone` etc. The `privateGraph` also uses the global schema object `Phone`. Thus, both the `financialGraph` and the `privateGraph`
share the `Phone` schema object. Additionally, the `privateGraph` has its own private schema objects—`Loan` and `Person` vertex objects.

To enter a graph scope, type the `USE GRAPH graphName` command in the GSQL shell. Then, use the `ls` command to list all
the schema objects under this graph scope.


[source,gsql]
----
> USE GRAPH privateGraph
> ls
----


== Schema Change Job
To safely update the graph schema, the user should follow this procedure:

* Create a schema change job, which defines a sequence of `ADD`, `ALTER`, and/or `DROP` statements.
* Run the schema change job (using `RUN SCHEMA_CHANGE JOB <job name>`),
which will do the following:
** Attempt the schema change.
** If the change is successful, invalidate any loading job or query definitions which are incompatible with the new schema
** If the change is unsuccessful, report the failure and return to the state before the attempt.


[CAUTION]
====
A schema change will invalidate any loading jobs or query jobs which relate to an altered part of the schema.
Specifically:

* A loading job becomes invalid if it refers to a vertex or and an edge which has been dropped (deleted) or altered.
* A query becomes invalid if it refers to a vertex, and edge, or an attribute which has been dropped.

Invalid loading jobs are dropped, and invalid queries are uninstalled. After the schema update, the user will need to create and install new load and query jobs based on the new schema.
====

[WARNING]
====
Load or query operations which begin before the schema change will be completed based on the pre-change schema. Load or
query operations which begin after the schema change, and which have not been invalidated, will be completed based on
the post-change schema.

Schema changes that are performed during times with high query or data loading volume may have a chance of failure. It
is considered good practice to perform schema changes during times of low graph activity.
====

=== Local Schema Change Job

As a reminder, here is the example schema of financialGraph that will be used to create the schema change job:

image::schema Graph GSQL.png[]



[source,gsql]
----
# create an empty graph named financialGraph
CREATE GRAPH financialGraph ()

# enter the graph scope
USE GRAPH financialGraph

# create a schema change job to add vertex/edge types
CREATE SCHEMA_CHANGE JOB financialGraph_schema_job {
   # add all vertex types
   ADD VERTEX Account ( name STRING PRIMARY KEY, isBlocked BOOL);
   ADD VERTEX City ( name STRING PRIMARY KEY);
   ADD VERTEX Phone (name STRING PRIMARY KEY, isBlocked BOOL);

   # add all edge types
   ADD DIRECTED EDGE Transfer (FROM Account, TO Account, DISCRIMINATOR(date DATETIME), amount UINT) WITH REVERSE_EDGE="Transfer_Reverse";
   ADD UNDIRECTED EDGE hasPhone (FROM Account, TO Phone);
   ADD DIRECTED EDGE isLocatedIn (FROM Account, TO City);
}

# run the schema change job
RUN SCHEMA_CHANGE JOB financialGraph_schema_job
----



A local schema change job is a schema object created under a current graph scope.
A `CREATE SCHEMA_CHANGE JOB` statement defines a new graph-scope schema change job. It specifies:

* The job name. For example,  `financialGraph_schema_job`
* A sequence of `ADD`, `ALTER`, and `DROP` statements separated by “;” for changing a particular
graph. It does not perform the schema change. In the above example, we use the `ADD` statements to create a list of vertex
and edge types for the graph `financialGraph`.


The job can be executed by the `RUN SCHEMA_CHANGE JOB jobName` command. After we execute the schema change
job, the catalog looks like Figure 3.

.The schema change job financialGraph_schema_job modifies the empty financialGraph by adding a list of local vertex and edge types
image::localGraph2.png[]


== ADD VERTEX|EDGE

ADD VERTEX and ADD EDGE statements are used to add existing global vertices/edges or create new vertices/edges to add to a graph’s scope. The `ADD VERTEX` statement specifies:

1. *Type Name*: A unique identifier for the edge type. Examples: `Transfer`, `hasPhone`, and `isLocatedIn`.
2. *Direction Property*: Specified by the `DIRECTED` or `UNDIRECTED` keyword.
** *DIRECTED*: Models an asymmetric relationship with a defined direction from the source vertex to the target vertex.
** *UNDIRECTED*: Models a symmetric relationship with no defined direction, simply connecting two vertices.
3. *Attributes*: Zero or more attributes can be defined, each with a name and an associated data type. Example: In the `Transfer` edge type, `amount` is an attribute with the data type `UINT`.
The available attribute types, including user-defined types, are listed in the section xref:values-and-types:values-and-types.adoc[Attribute Data Types]
4. *Discriminator*: By default, only one instance of an edge type is allowed between two vertices. You can add an optional
discriminator (specified by the keyword `DISCRIMINATOR`) to the edge type definition to differentiate multiple instances of one
edge type between two vertices. Example: The `Transfer` edge type uses the `date` attribute as its discriminator to differentiate
multiple Transfer edges between the same account pair (Scott, Ed).   Only INT, UINT , DATETIME and STRING types are allowed
to be discriminators for edge types. The specification of the discriminator must come before other attributes.

5. *Source and Target Vertex Type pair(s)*: specifies at least one pair of source and target vertex types, that is, the vertex types on both ends of the edge. In GSQL, they are often referred to as the FROM vertex and the TO vertex, respectively, to reflect the keywords used to define the edge type.
Examples: `Transfer`, `hasPhone`, and `isLocatedIn` edges connect their respective `FROM` and `TO` vertex types. For an undirected edge, either vertex type can be at the source (the `FROM`) position, and the remaining one will take the target (the `TO`) position.
6. *Reverse Edge Type*: For directed edges, you can optionally use `WITH REVERSE_EDGE = reverse_edge_name` to specify a reverse edge type, which shares the same schema as the forward edge type but in the opposite direction and has a unique name. This is useful when writing queries to traverse both directions of an edge. Example: For each `Transfer` edge, a reverse edge `Transfer_Reverse` is created, flipping the source and target of the `Transfer` edge.

Here is the syntax for adding vertices and edges in schema change jobs:
[source, gsql]
----
# an add vertex statement
ADD VERTEX vertex_name ( [one attribute] DISCRIMINATOR, [zero or more attributes]);

# an add edge statement
 ADD DIRECTED | UNDIRECTED EDGE edge_name (FROM from_vertex, TO to_vertex, DISCRIMINATOR(optional_discriminator discriminator_type), [one or more attributes]) WITH REVERSE_EDGE=”optional_reverse_edge”
----

== DROP VERTEX|EDGE
Dropping a vertex/edge from a graph schema will remove it from the scope of the graph.
The `DROP VERTEX` and the `DROP EDGE` statements specify:

1. *Type Name*: A unique string identifier for the vertex or edge type to be dropped. For
example, `Account`, `isLocatedIn` type names.

Below are some examples of the DROP statement, all of which should be part of the body of a schema change job.

[source,gsql]
----
# a drop vertex statement
DROP VERTEX City, Phone;

# a drop edge statement
DROP EDGE isLocatedIn;
----


== ALTER VERTEX|EDGE
`ALTER VERTEX` and `ALTER EDGE` statements are used to add or subtract attributes to existing edges or vertices.
These statements are followed by the attributes to `ADD` or `DROP`.
`ALTER` statments specify:

1. *Type Name*: A unique string identifier for the vertex or edge type to be modified.
2. *Attribute name list* to be added or dropped.
3. *Edge (source, target) pairs* to be added.

Here are some examples of the ALTER statement on vertex and edge types. All of them should be part of the body of a schema change job.

[source,gsql]
----
# change attributes of the Account vertex schema
ALTER VERTEX Account ADD ATTRIBUTE (age UINT, gender STRING);
ALTER VERTEX Account DROP ATTRIBUTE (isBlocked);

# change attributes of the hasPhone edge schema
ALTER EDGE hasPhone ADD ATTRIBUTE (model STRING);

# add a new (source,target) pair to the hasPhone edge
ALTER EDGE hasPhone ADD PAIR (FROM City, TO Phone);
----


== Global Schema Change Job
The `CREATE GLOBAL SCHEMA_CHANGE JOB` block defines a sequence of `ADD`, `ALTER`, and `DROP` statements that modify either
the attributes of a global vertex or edge types, or add (or drop) the global vertex or edge  types to( or from) a graph.
Unlike the non-global schema change job, a USE GRAPH statement is not included. However, the `ADD`/`ALTER`/`DROP` statements
in the body do reference graphs.

[source,gsql]
----
# enter the global scope
USE GLOBAL

CREATE GRAPH privateGraph()

# create a global schema change job to add global vertex/edge types to the graph
CREATE GLOBAL SCHEMA_CHANGE JOB updatePrivateGraph {

   # modify a the global vertex Account
   ALTER VERTEX Account ADD ATTRIBUTE (age UINT, gender STRING);
   ALTER VERTEX Account DROP ATTRIBUTE (isBlocked);

   # add the global Phone vertex to privateGraph
   ADD VERTEX Phone TO GRAPH privateGraph;

}

# run the schema change job
RUN GLOBAL SCHEMA_CHANGE JOB updatePrivateGraph
----


=== Drop A Schema Change Job
To drop a schema job, use the `DROP JOB` command, which specifies:

1. *Job Name*: the schema change job name

[source,gsql]
----
# drop a global schema change job
USE GLOBAL
DROP JOB updatePrivateGraph

# drop a graph scope schema change job
USE GRAPH financialGraph
DROP JOB financialGraph_schema_job

----

=== Drop All

The `DROP ALL` command clears all graph data, all graph schemas, all loading jobs, and all queries. It should only be used when the intent is to erase an entire database design and to start over.


This command is only available to superusers and only when they are in global mode.

==== -N Option
Additionally, an option `-N` is currently supported for both local and global schema change jobs.
Option `-N`, for both global and local scopes, will mark the queries as deprecated and the user will need to manually
re-install the deprecated queries.

[source,gsql]
----
# do schema change, and invalidate all queries.
USE GLOBAL
RUN GLOBAL SCHEMA_CHANGE JOB updatePrivateGraph -N

USE GRAPH financialGraph
RUN SCHEMA_CHANGE JOB financialGraph_schema_job -N
----





