= Core Concepts

In order to query a graph database, we need to understand some core concepts that serve as the building blocks of graph query.

== Graph Pattern
Imagine drawing a line over an image of the graph, starting from a particular vertex and tracing a route across edges and vertices to another vertex.

A graph pattern is exactly that - a traversal trace on the graph schema. The pattern declares what the user wants from the graph, and the database query processor will match the pattern and return all the matching graph elements.

== Node Pattern

The most basic pattern in a graph query is node pattern. Example

[source,gsql]
----
// V2 Syntax
FROM Account:x
WHERE x.isBlocked == TRUE
----
In the above example, a node pattern is specified in the FROM clause. It specifies:

* The `Account` vertex type.
* A variable "x", binds to all the vertices that match the Account node pattern.

The `WHERE` clause is the post-matching filter, which uses the bind variable x to access the attributes of the matching vertices.

Note that we use prefix double dashes "--" to insert comments.

The same node pattern can be specified using syntax V3 without the `WHERE` clause.

[source,gsql]
----
// V3 Syntax
FROM (x:Account {isBlocked: TRUE})
----


In the above syntax V3 example, a node pattern uses () to denote. And the binding variable x is specified before the vertex type. And we use JSON-style key-value pairs to specify the attribute filter where “isBlocked” is the attribute of x, and “true” is the value of the attribute.

== Edge Pattern
The second most basic pattern in a graph query is edge pattern. Example

[source,gsql]
----
// V2 Syntax
FROM Account:x - (Transfer>:e)- Account:y
WHERE x.isBlocked == TRUE AND y.isBlocked == FALSE
----

In the above example, an edge pattern is specified in the `FROM` clause. It specifies:

* The source `Account` vertex  type with binding variable x.
* The target `Account` vertex type with binding variable y.
* The `Transfer` edge type connecting the source and the target, e is the binding variable to refer to all the matches of the edges. The “>” signifies the directed edge’s direction.

The `WHERE` clause is the post-matching filter, where a Boolean expression is specified using the binding variables in the edge pattern.

We can write the same edge patterns by flipping the source and target’s syntactic position, and change the direction “>” accordingly to “<”.

[source,gsql]
----
// V2 Syntax
FROM Account:y - (<Transfer:e)- Account:x
WHERE x.isBlocked == TRUE AND y.isBlocked == FALSE
----

For an undirected edge, we can just drop the direction decorator. That is `- (EdgeName:e) -`.

[source,gsql]
----
// V2 Syntax
FROM Account:x - (hasPhone:e)- Phone:z
WHERE x.isBlocked == TRUE
----


The same edge patterns can be specified using syntax V3 without the `WHERE` clause.

[source,gsql]
----
// V3 Syntax
FROM (x:Account {isBlocked: TRUE}) -[e:Transfer]-> (y:Account {isBlocked: FALSE})
FROM (y:Account {isBlocked: FALSE}) <-[e:Transfer]- (x:Account {isBlocked: TRUE})
FROM (x:Account {isBlocked: TRUE}) -[e:hasPhone]- (z:Phone)
----
In the above syntax V3 example, a node pattern uses () to denote, and edge pattern is -[]\->.
And the binding variable is specified before the vertex or edge type (vs. syntax v2 binding variable is after the vertex or edge type). And we use JSON-style key-value pairs to specify the attribute filter. The direction of the edge is indicated by \-> or \<-, or - -.



== Path Pattern
By alternating node and edge pattern, we form a path pattern.

.Example 1
[source, gsql]
----
FROM Account:x- (Transfer>:e) - Account:z - (<Transfer) - Account:y
----
In the above example, we connect two edge patterns via the node pattern `Account:z`. We do not specify a binding variable for the second `Transfer` edge type since we do not intend to reference it in any expression.

This path pattern specifies that find all accounts x, who transferred money to z, and z received money from y.

.Example 2
[source,gsql]
----
FROM Account:x- (Transfer>) - Account:z - (Transfer>) - Account:y
----

In the above example, we connect two edge patterns that have the same direction via the node pattern `Account:z`. There is a shorthand syntax sugar to express this as below.

[source,gsql]
----
FROM Account:x- (Transfer>*2) - Account:y
----

GSQL pattern matching makes it easy to express such variable-length patterns which repeat a single hop. Everything else stays the same as introduced in the previous section, except we append an asterisk (or Kleene star) and an optional min..max range to an edge pattern.

* (E*) means edge type E repeats any number of times (including zero)
* (E*1..3) means edge type E occurs one to three times.

Below are more illustrative examples:

* 1-hop star pattern -- repetition of an edge pattern 0 or more times
a. `FROM X:x -(E*)- Y:y`
b. `FROM X:x -(F>*)- Y:y`
c. `FROM X:x -(<G*)- Y:y`
d. `FROM X:x -(_*)- Y:y`
** Any undirected edge can be chosen at each repetition.
e. FROM X:x -(_>*)- Y:y
** Any right-directed edge can be chosen at each repetition.
f. FROM X:x -(<_*)- Y:y
** Any left-directed edge can be chosen at each repetition.
g. FROM X:x -((E|F>|<G)*)- Y:y
** Either E, F> or <G can be chosen at each repetition.
* 1-hop star pattern with bounds
a. FROM X:x -(E*2..)- Y:y
** Lower bounds only. There is a chain of at least 2 E edges.
b. FROM X:x -(F>*..3)- Y:y
** Upper bounds only. There is a chain of between 0 and 3 F edges.
c. FROM X:x -(<G*3..5)- Y:y
** Both Lower and Upper bounds. There is a chain of 3 to 5 G edges.
d. FROM X:x -((E|F>|<G)*3)- Y:y
** Exact bound. There is a chain of exactly 3 edges, where each edge is either E, F>, or <G.


== Shortest Paths Only for Variable Length Patterns
If a pattern has a Kleene star to repeat an edge, GSQL pattern matching selects only the shortest paths which match the pattern. If we did not apply this restriction, computer science theory tells us that the computation time could be unbounded or extreme (NP = non-polynomial, to be technical). If we instead matched ALL paths regardless of length when a Kleene star is used without an upper bound, there could be an infinite number of matches, if there are loops in the graph. Even without loops or with an upper bound, the number of paths to check grows exponentially with the number of hops.


image::queries:Screenshot 2024-07-23 at 11.40.08 AM.png[]


For the pattern `1 - (_*) - 5` in Figure 3 above, you can see the following:

* There are TWO shortest paths: 1-2-3-4-5 and 1-2-6-4-5
** These have 4 hops, so we can stop searching after 4 hops. This makes the task tractable.
* If we search for ALL paths which do not repeat any vertices:
** There are THREE non-repeated-vertex paths: 1-2-3-4-5, 1-2-6-4-5, and 1-2-9-10-11-12-4-5
** The actual number of matches is small, but the number of paths is theoretically very large.
* If we search for ALL paths which do not repeat any edges:
** There are FOUR non-repeated-edge paths: 1-2-3-4-5, 1-2-6-4-5, 1-2-9-10-11-12-4-5, and 1-2-3-7-8-3-4-5
** The actual number of matches is small, but number of paths to consider is NP.
* If we search for ALL paths with no restrictions:
** There are an infinite number of matches, because we can go around the 3-7-8-3 cycle any number of times.








